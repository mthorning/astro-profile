---
declare global {
  interface GlobalEventHandlersEventMap {
    "rain:stop": CustomEvent;
  }
}
---

<style>
  canvas {
    width: 100%;
    height: 100%;
  }
</style>

<script>
  window.onload = () => {
    const obj = document.getElementById("wet-object") as HTMLDivElement;
    const canvas = document.getElementById("cw") as HTMLCanvasElement;
    const context = canvas.getContext("2d");
    let objCoords: DOMRect;

    function setCoords() {
      objCoords = obj.getBoundingClientRect();
    }

    function setSize() {
      canvas.height = innerHeight;
      canvas.width = innerWidth;
      setCoords();
    }
    window.addEventListener("resize", () => setSize());
    window.addEventListener("scroll", () => setCoords());
    setSize();

    if (!context) throw new Error("No context");

    class RainDrop {
      x: number = 0;
      y: number = 0;
      gravity: number = 0;
      rainDropTrailWidth: number = 2;
      strokeColor: string = "#000";
      hasFallen: boolean = false;

      constructor() {
        this.init();
      }

      init() {
        this.y = 0;
        this.x = Math.random() * innerWidth;
        this.gravity = Math.random() * 10;
        this.hasFallen = false;
        this.strokeColor = this.generateColor();
      }

      fall() {
        if (!context) throw new Error("No context");
        context.beginPath();
        context.lineWidth = this.rainDropTrailWidth;
        context.strokeStyle = this.strokeColor;

        const splashY =
          this.x > objCoords.left && this.x < objCoords.right
            ? objCoords.top + window.scrollY
            : undefined;

        if (this.gravity > 3 && splashY && this.y + this.gravity >= splashY) {
          this.y = splashY;
          this.splash(splashY);
        } else {
          context.moveTo(this.x, this.y);
          this.y += this.gravity;
          context.lineTo(this.x, this.y);
          context.stroke();
          this.hasFallen = this.y >= innerHeight;
        }
      }

      generateColor(): string {
        let hexSet = "0123456789ABCDEF";
        let finalHexString = "#";
        for (let i = 0; i < 6; i++) {
          finalHexString += hexSet[Math.ceil(Math.random() * 15)];
        }
        return finalHexString;
      }


      splash(splashY: number) {
        if (!context) throw new Error("No context");
        const rnd = (Math.random() * this.gravity) / 5;
        context.moveTo(this.x, splashY);
        context.lineTo(this.x - rnd * 6, splashY - rnd * 3);
        context.stroke();
        context.moveTo(this.x, splashY);
        context.lineTo(this.x + rnd * 6, splashY - rnd * 3);
        context.stroke();
        this.hasFallen = true;
      }

    }

    class Cloud {
      rainDrops: RainDrop[] = [];
      fallingDrops: RainDrop[] = [];
      maxFallingDrops: number;
      isRaining: boolean = true;

      constructor(initialRainDrops: number, maxFallingDrops: number) {
        window.addEventListener("rain:stop", () => {
          this.isRaining = false
        });
        window.addEventListener("rain:start", () => {
          this.isRaining = true
        });
        this.maxFallingDrops = maxFallingDrops;
        for (let i = 0; i < initialRainDrops; i++) {
          this.rainDrops.push(
            new RainDrop(),
          );
        }
      }

      dropRainDrop() {
        this.fallingDrops.push(this.rainDrops.pop() as RainDrop);
      }

      rain() {
        if (!context) throw new Error("No context");
        if (this.fallingDrops.length < this.maxFallingDrops && this.isRaining) {
          this.dropRainDrop();
        }

        this.fallingDrops.forEach((rainDrop, i) => {
          rainDrop.fall();
          if (rainDrop.hasFallen) {
            this.fallingDrops.splice(i, 1);
            rainDrop.init();
            this.rainDrops.push(rainDrop);
          }
        });
      }
    }

    const cloud = new Cloud(Math.max(window.innerWidth, 1200), 500);

    setInterval(() => {
      context.clearRect(0, 0, canvas.width, canvas.height);
      cloud.rain();
    }, 10);
  };
</script>

<canvas id="cw"></canvas>
